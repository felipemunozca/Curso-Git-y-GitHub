<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!--bootstrap 5-->
    <link rel="stylesheet" href="css/bootstrap.min.css">

    <!--css propio-->
    <link rel="stylesheet" href="css/estilos.css">

    <title>Mis apuntes del curso</title>
</head>
<body>
    <div class="container">
        <div class="titulo">
            <h4>En el curso de Git y GitHub vimos un ejemplo llamado “blogpost”, a continuación, se detallarán los apuntes destacados, así como los comandos necesarios para realizar el taller.</h4>
            <br>
        </div>
        <div>
            <!--inicio seccion capitulo dos-->
            <h3>Capítulo 2: Comandos básicos en Git </h3>
            <div class="accordion accordion-flush" id="panelAcordion2">
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado08">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso08" aria-expanded="false" aria-controls="panelColapso08">
                            Crear un repositorio
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso08" aria-labelledby="panelEncabezado08" data-bs-parent="#panelAcordion2">
                        <div class="accordion-body">
                            <p>Para crear un repositorio debes indicar donde estará la carpeta central de tus archivos, por ejemplo, en un sitio web, seria donde está el archivo index.html</p>
                            <ul>
                                <li><span class="consola">git-init</span> -> comando para iniciar un repositorio. Debes estar en la ruta de la carpeta que utilizaras. se creará una carpeta oculta llamada .git</li>
                                <li><span class="consola">code</span> -> si escribes este comando en la terminal, se abrirá de modo automático visual studio code.</li>
                                <li><span class="consola">git status</span> -> comando para saber cual es el estatus del proyecto. Nos dirá en que rama estamos, los commits realizados y si hay algún archivo que aún no se agrega al proyecto</li>
                                <li><span class="consola">git add</span> -> comando para agregar un archivo al proyecto. Por ejemplo: <span class="ejemplos">git add historia.txt</span></li>
                                <li><span class="consola">git rm</span> -> comando para eliminar un archivo del directorio. El archivo no se elimina de la carpeta, sino que se elimina de los archivos disponibles del directorio de GIT. Por ejemplo: <span class="ejemplos">git rm historia.txt</span></li>
                                <li><span class="consola">git rm --cache</span> -> comando para eliminar un archivo de la memoria ram. Por ejemplo: <span class="ejemplos">git rm --cache historia.txt</span></li>
                                <li><span class="consola">git commit</span> -> comando que envia los cambios al repositorio. Una mala practica es solo ejecutar este comando si agregar un comentario de que es lo que se esta cambiando. Se debe agregar -m "" y entre las comillas agregar un mensaje. Por ejemplo: <span class="ejemplos">git commit -m "Este es el primer commit de este archivo"</span></li>
                            </ul>
                            <p>Si se ejecuta este comando si haber realizado una configuración de GIT, nos aparecerá un error indicando que se deben agregar un nombre de usuario y un correo. Para identificar quien es la persona que esta realizando estos cambios.</p>
                            <ul>
                                <li><span class="consola">git config</span> -> comando para ver todas las configuraciones que tiene git.</li>
                                <li><span class="consola">git config --list</span> -> comando para ver la configuración por defecto de GIT. También podremos ver las configuraciones que le faltan.</li>
                                <li><span class="consola">git config --global</span> -> comando para cambiar todos los usuarios globales.</li>
                                <li><span class="consola">git config --global user.name</span> -> comando para cambiar el nombre de la configuración global. El nombre debe ir entre comillas. Por ejemplo: <span class="ejemplos">git config --global user.name "Felipe Munoz"</span></li>
                                <li><span class="consola">git config --global user.email</span> -> comando para cambiar el correo de la configuración global. El correo debe ir entre comillas. Por ejemplo <span class="ejemplos">git config --global user.name "analista.felipe.m@gmail.com"</span>. <p class="notas">NOTA: para hacer la arroba en gitbash utilizar las teclas ALT GR + Q.</p></li>
                            </ul>
                            <p>con esta configuración realizada, ya puedo volver a intentar realizar el primer commit.</p>
                            <p>Si ejecuto el comando de commit y agrego una descripción y luego intento guardar, me aparecerá un error, ya que SIEMPRE tengo que primero agregar los cambios con el comando git add.</p>
                            <ul>
                                <li><span class="consola">git add .</span> -> con el punto al final puedo decirle al sistema que me agregue todos los archivos. Esto se utiliza cuando estoy editando mas de un archivo a la vez.</li>
                                <li><span class="consola">git log</span> -> comando para ver todo el historial de commit que he escrito. Por ejemplo: <span class="ejemplos">git log historia.txt</span></li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado09">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso09" aria-expanded="false" aria-controls="panelColapso09">
                            Analizar cambios en los archivos
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso09" aria-labelledby="panelEncabezado09" data-bs-parent="#panelAcordion2">
                        <div class="accordion-body">
                            <ul>
                                <li><span class="consola">git show</span> -> comando que te muestra los cambios que ha tenido el archivo. En rojo aparecerá el texto o código original, y en verde los cambios o texto nuevo. Por ejemplo: <span class="ejemplos">git show historia.txt</span></li>
                            </ul>
                            <p>Si intento agregar un commit sin un mensaje, aparecerá una pantalla llamada VIM en donde te SUGIEREN que escribas algo.</p>
                                <ul>
                                    <li>Para escribir texto en VIM, debo presionar las teclas ESC + I. El mensaje se escribira en letras amarillas.</li>
                                    <p class="notas">Si intento escribir un mensaje y luego presiono ENTER más de una vez y luego escribo otra parte del mensaje, la primera línea de texto aparecerá en color amarillo, mientras que las demás estarán en color blanco o gris, esto es una mala práctica, ya que ese texto quedara separado por espacios en blanco y que pueden producir errores de lectura.</p>
                                    <li>Al terminar, presionar la tecla ESC.</li>
                                    <li>En la parte de abajo de la pantalla, aparecerá una línea en donde se podrá teclear SHIFT + Z + Z para cerrar la pantalla de VIM.</li>
                                </ul>
                            <p>Como comparar los cambios entre un commit y otro </p>
                                <ul>
                                    <li><span class="consola">git diff</span> -> comando para comparar los cambios ocurridos entre commit y commit. se debe copiar el codigo con el que se almacena cada commit y luego separarlos con espacio para comparar. Por ejemplo: <span class="ejemplos">git diff 00f119a85ba6858cfb5a6858e6592f8fcade998b 002a003c31eceb2ecd22f19113c969c775d1bdda</span></li>
                                    <p class="notas">En verde me aparece la versión original.En rojo me muestra los cambios y textos agregados.</p>
                                </ul>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado10">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso10" aria-expanded="false" aria-controls="panelColapso10">
                           Staging
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso10" aria-labelledby="panelEncabezado10" data-bs-parent="#panelAcordion2">
                        <div class="accordion-body">
                            <p>Staging -> área creada en memoria ram luego de escribir el comando git init.</p>
                            <p>Carpeta /.git/ -> Carpeta donde se almacena la base de datos del repositorio.</p>
                            <p>Cuando escribes el comando <span class="consola">git add</span> los cambios pasan a vivir dentro del área de staging (estado temporal)</p>
                            <img class="imagen-extra" src="img/10.png" alt="">
                            <p><span class="consola">checkout</span> -> comando para traer cambios que pudo realizar otra persona en un proyecto compartido. </p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado11">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso11" aria-expanded="false" aria-controls="panelColapso11">
                            Branch
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso11" aria-labelledby="panelEncabezado11" data-bs-parent="#panelAcordion2">
                        <div class="accordion-body">
                            <p>por defecto, el proyecto comienza en la rama MASTER, donde estaría la versión 1 de lo que queramos hacer.</p>
                            <p>Con cada commit puedes ir creando tantas versiones como quieras.</p>
                            <p>puedes crear ramas a partir del commit que quieras. Poe ejemplo: tu proyecto funciona hasta cierto punto, pero quieres probar que tal funcionara con otra librería o plugins, puedes crear una rama para realizar pruebas sin afectar lo que ya funciona bien.</p>
                            <p>Puede darse el caso en que el proyecto este en una etapa final y te des cuenta que tiene un bug grave que obliga a modificar cosas. Para esto se recomienda crear una nueva rama que es conocida como BUGFIXING o HOTFIX (arreglo en caliente) en donde se realizaran todas las pruebas y una vez corregido el error, se une esta rama a la rama principal MASTER.</p>
                            <p>merge -> es cuando unes los cambios de una rama con otra. </p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado12">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso12" aria-expanded="false" aria-controls="panelColapso12">
                            Volver en el tiempo
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso12" aria-labelledby="panelEncabezado12" data-bs-parent="#panelAcordion2">
                        <div class="accordion-body">
                            <p>En el caso en que se quiera volver en el tiempo de mi proyecto, por ejemplo, volver al commit 2 se utilizó el comando <span class="consola">git log</span> y el nombre del archivo para seleccionar un punto de restauración.</p>
                            <ul>
                                <li><span class="consola">git reset</span> -> comando que permite volver a una versión anterior. Por ejemplo: <span class="ejemplos">git reset 00f119a85ba6858cfb5a6858e6592f8fcade998b</span></li>
                            </ul>
                            <p>Existen 2 tipos de reset:</p>
                            <ul>
                                <li><span class="consola">git reset --hard</span> -> TODO vuelve al estado anterior. Por ejemplo: <span class="ejemplos">git reset 00f119a85ba6858cfb5a6858e6592f8fcade998b --hard</span></li>
                                <li><span class="consola">git reset --soft</span> -> Volvemos a la versión anterior, pero mantiene todo lo que está en staging, que puede volver a agregarse. Por ejemplo: <span class="ejemplos">git reset 00f119a85ba6858cfb5a6858e6592f8fcade998b --soft</span></li>
                            </ul>
                            <p>Si reviso el archivo historia.txt y el comando fue bien escrito, todos los últimos cambios serán eliminados y volverá a la segunda versión del texto.</p>
                            <p class="linea-separacion"></p>
                            <p>Aquí comienza a desarrollarse el proyecto del curso: </p>
                            <ul>
                                <li>Creo un archivo blogpost.html con un diseño básico.</li>
                                <li>Ejecuto el comando <span class="consola">git status</span> y reconoce el nuevo archivo html.</li>
                                <li>Agrego el archivo con el comando <span class="consola">git add .</span></li>
                                <li>Vuelvo a revisar con <span class="consola">git status</span> y ahora deberia aparecer como agregado (el nombre del archivo en verde)</li>
                                <li>Creo una carpeta css y un archivo de estilos.css</li>
                                <li>Agrego estilos y se anexo a la página html.</li>
                                <li>Con <span class="consola">git diff</span> puedo ver la diferencia que hay entre el staging (lo que está guardado en la ram) y lo que está en el directorio (lo que esta guardado en el disco duro)</li>
                                <li>Vuelvo a ejecutar <span class="consola">git add .</span> para agregar los nuevos cambios y archivos y estarán todos en staging</li>
                                <li>Guardo los cambios <span class="ejemplos">commit -am "arranco mi proyecto real con html y css"</span> y los cambios son subidos.</li>
                                <li>Ejecuto el comando <span class="consola">git log</span> y veo que se agregó el nuevo commit, y que aparecen el primer y segundo commit, pero el resto fueron borrados al hacer un reset hard.</li>
                                <li>Ejecuto el comando <span class="consola">git log --stat</span> para ver los cambios que se hicieron por archivos expresados en bytes.</li>
                                <li>Y con el comando <span class="consola">git checkout</span> podre VER como se veia un archivo en cierto commit. Por ejemplo <span class="ejemplos">git checkout 002a003c31eceb2ecd22f19113 blogpost.html</span></li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado13">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso13" aria-expanded="false" aria-controls="panelColapso13">
                            Git reset VS Git rm
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso13" aria-labelledby="panelEncabezado13" data-bs-parent="#panelAcordion2">
                        <div class="accordion-body">
                            <strong>git rm</strong>
                            <p>Este comando nos ayuda a eliminar archivos de Git sin eliminar su historial del sistema de versiones. Esto quiere decir que si necesitamos recuperar el archivo solo debemos “viajar en el tiempo” y recuperar el último commit antes de borrar el archivo en cuestión.</p>
                            <p>Recuerda que <span class="consola">git rm</span> no puede usarse así nomás. Debemos usar uno de los flags para indicarle a Git cómo eliminar los archivos que ya no necesitamos en la última versión del proyecto</p>
                            <ul>
                                <li><span class="consola">git rm --cached</span> -> Elimina los archivos de nuestro repositorio local y del área de staging, pero los mantiene en nuestro disco duro. Básicamente le dice a Git que deje de trackear el historial de cambios de estos archivos, por lo que pasaran a un estado untracked.</li>
                                <li><span class="consola">git rm --force</span> -> Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).</li>
                            </ul>
                            <strong>git reset</strong>
                            <p>Este comando nos ayuda a volver en el tiempo. Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado sin la posibilidad de volver al presente. Borramos la historia y la debemos sobreescribir. No hay vuelta atrás.</p>
                            <p>Este comando es <strong>MUY PELIGROSO</strong> y debemos usarlo solo en caso de emergencia. Recuerda que debemos usar alguna de estas dos opciones:</p>
                            <p>Hay dos formas de usar git reset:</p>
                            <ul>
                                <li><span class="consola">git reset --soft</span> -> Borramos todo el historial y los registros de Git pero guardamos los cambios que tengamos en Staging, así podemos aplicar las últimas actualizaciones a un nuevo commit.</li>
                                <li><span class="consola">git reset --hard</span> -> Borra todo. Todo, absolutamente todo. Toda la información de los commits y del área de staging se borra del historial.</li>
                            </ul>
                            <p>¡Pero todavía falta algo!</p>
                            <ul>
                                <li><span class="consola">git reset HEAD</span> -> Este es el comando para sacar archivos del área de staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!--cierre seccion capitulo dos-->

            <br>

            <!--inicio seccion capitulo tres-->
            <h3>Capítulo 3: Flujo de trabajo básico en Git</h3>
            <div class="accordion accordion-flush" id="panelAcordion3">
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado14">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso14" aria-expanded="false" aria-controls="panelColapso14">
                            Flujo de trabajo básico con un repositorio remoto
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso14" aria-labelledby="panelEncabezado14" data-bs-parent="#panelAcordion3">
                        <div class="accordion-body">
                            <p>Cuando se trabaja en equipo en un mismo proyecto, se debe subir la informacion a un servidor remoto o tambien llamado repositorio remoto. Ejemplos de esto pueden ser: GitHub, GitLab, BitBucket o puede ser tu propio servidor.</p>
                            <strong>Repositorio remoto</strong>
                            <p>Cuando se quiere comenzar a trabajar con un servidor remoto, en vez de comenzar el proyecto con el comando <span class="consola">git init</span>, se utiliza el comando <span class="consola">git clone</span> y la url del servidor.
                            </p>
                            <ul>
                                <li>Por ejemplo: <span class="ejemplos">git clone https://github.com/libgit2/libgit2</span>
                                Lo que hace git clone es hacer una copia de toda la ruta master y crea la base de datos de todos los cambios históricos en mi propio repositorio local.</li>
                            </ul>
                            <p>Una vez que realice todos los cambios que eran necesarios, así como las mejoras, debo subir la información al servidor remoto utilizando el comando <span class="consola">git push</span></p>
                            <p>Si hay mas personas trabajando en el repositorio remoto y están subiendo cambios, puedo traer esas actualizaciones a mi repositorio local utilizando el comando <span class="consola">git fetch</span> (Trae los cambios pero no los copia en mis archivos)</p>
                            <p>Y para poder copiar los cambios a mis archivos, debo fusionar la última versión de mi trabajo en local con las actualizaciones utilizando el comando <span class="consola">git merge</span>.</p>
                            <p>Hay una forma más rápida de hacer la actualización y la descarga, estos es con el comando <span class="consola">git pull</span>.</p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado15">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso15" aria-expanded="false" aria-controls="panelColapso15">
                            Introducción a ramas de Git
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso15" aria-labelledby="panelEncabezado15" data-bs-parent="#panelAcordion3">
                        <div class="accordion-body">
                            <p>Al inicio del proyecto se comienza con una rama llamada master la cual se puede ver en la consola con el nombre de la carpeta. <span class="ejemplos">Sxxxx@LAPTOP-630B MINGW64 ~/proyecto1 (master)</span></p>
                            <p>Las ramas son la forma en la que podemos hacer cambios para probar diferentes opciones, sin que estos afecten la rama principal (master).</p>
                            <p>Cuando uno crea una rama lo que hace básicamente es una copia del ultimo commit en otro lado.</p>
                            <p class="linea-separacion"></p>
                            <p>Volviendo al ejemplo del curso</p>
                            <ul>
                                <li>Se comienza por editar el archivo blogpost.html y estilos.css agregando modificaciones al código.</li>
                                <li>En la terminal se ejecuta el comando <span class="consola">git status</span> y muestra que han ocurrido cambios en los archivos ya nombrados.</li>
                                <li>Para guardar los cambios también puedo usar el comando <span class="consola">git commit -a</span>. Se abrira un entorno llamado VIM para escribir un mensaje. Se presionan las teclas ESC + I para escribir. Luego ESC SHIFT + Z + Z para guardar y cerrar.</li>
                                <li>Ejecuto el comando <span class="consola">git log</span> para ver si se guardó el cambio.</li>
                                <li>Ejecuto el comando <span class="consola">git log --stat</span> puedo leer la información de cuantos kilobytes se agregaron o quitaron, así como la cantidad de atributos de código que se agregaron y quitaron.</li>
                                <li>una vez que termino de realizar los cambios a la versión más actualizada de la rama master, ejecuto el comando <span class="consola">git show</span> para ver donde está el HEAD. Para este caso está apuntando a master. Por ejemplo: <span class="ejemplos">(HEAD -> master)</span></li>
                            </ul>
                            <p class="notas">NOTA: cuando el texto que aparece en pantalla es mas largo que la vista de la terminal y no puedes bajar si no es con la tecla ENTER. Se debe presionar la tecla Q para salir del comando y volver a la linea de consola normal.</p>
                            <strong>Branch</strong>
                            <ul>
                                <li>Para crear una nueva rama, se utiliza el comando <span class="consola">git branch</span> y el nombre de la rama. Por ejemplo: <span class="ejemplos">git branch cabecera</span></li>
                                <li>si vuelvo a ejecutar el comando <span class="consola">git show</span> ahora aparecerá que el HEAD apunta tanto al master como a la cabecera <span class="ejemplos">(HEAD -> master, cabecera)</span></li>
                                <li>Para moverme a la otra rama debo utilizar el comando <span class="consola">git checkout</span> y el nombre de la rama. Por ejemplo <span class="ejemplos">git checkout cabecera</span></li>
                                <li>Ahora en la línea de la terminal aparece que estoy trabajando en la cabecera. <span class="ejemplos">Sxxxx@LAPTOP-630B6 MINGW64 ~/proyecto1 (cabecera)</span></li>
                                <li>Ahora vuelvo a editar el archivo de blogpost.html agregando un header. Ejecuto nuevamente el comando <span class="consola">git status</span> y aparece que se realizó un cambio en el archivo blogpost.html.</li>
                                <li>para guardar los cambios ejecuto el comando <span class="ejemplos">git commit -m "estructura inicial de la cabecera"</span></li>
                                <li>Si ahora utilizo <span class="consola">git log</span> y me mostrara los commit que estaban guardados en la ruta (master) y el HEAD que ahora esta en cabecera.</li>
                                <li>Y si vuelvo a la rama master con el comando <span class="ejemplos"> git checkout master</span> y reviso el archivo blogpost.html el código que había agregado desaparece. Pero si vuelvo a la rama cabecera, el código que agregue, vuelve a aparecer, esa es la magia de git.</li>
                            </ul>
                            <img class="imagen-extra" src="img/15.2.png">
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado16">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso16" aria-expanded="false" aria-controls="panelColapso16">
                            Fusión de ramas con Git merge
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso16" aria-labelledby="panelEncabezado16" data-bs-parent="#panelAcordion3">
                        <div class="accordion-body">
                            <p>En la rama CABECERA voy a realizar cambios al archivo blogpost.html y estilos.css creando un header.</p>
                            <p>Guardo los en la base de datos de git con los comandos de <span class="consola">git add</span> y luego <span class="consola">git commit</span>.</p>
                            <p>Ahora si vuelvo a la rama MASTER puedo ver que todo el código que he agregado en el header desaparece, pero aprovechare para agregar contenido nuevo en un párrafo al archivo blogpost.html y cambio la fuente del archivo estilos.css</p>
                            <p>Guardo los nuevos cambios. Por ejemplo <span class="ejemplos">git commit -am "Agregado el contenido adicional del blog y una mejor tipografía"</span></p>
                            <p>Ya que tengo el header listo y ademas agregue nueva información, quiero unir todos los cambios en una sola rama, para esto tengo que hacer un merge.</p>
                            <p class="linea-separacion"></p>
                            <p><strong>Merge</strong></p>
                            <p>Para hacer un merge tengo que fijarme en que rama estoy. Si estoy en la rama CABECERA este comando traerá todo lo de la rama MASTER y CABECERA pasara a ser la rama principal.</p>
                            <p>Y si lo que quiero hacer es traer los cambios de la rama CABECERA a la rama MASTER, debo hacer un checkout y volver a la rama MASTER. Aquí invoco el comando merge y creara un commit nuevo fusionando el ultimo commit de MASTER y el ultimo commit de CABECERA.</p>
                            <p>Si existe un conflicto entre los archivos, por ejemplo, que dos personas hagan cambios a la misma línea de código (colocarle dos id distintos a la misma variable), no me permitirá hacer el merge hasta que alguien lo arregle.</p>
                            <p>Una vez que arreglo los conflictos, reviso que estoy en la rama MASTER con <span class="consola">git status</span>, y luego apunto a la rama que quiro unir con merge. Por ejemplo: <span class="ejemplos">git merge cabecera</span></p>
                            <p>Al ejecutar <span class="consola">git merge</span> se abrirá la consola VIM en donde debo dejar un mensaje. ESC + I para insertar y luego ESC + SHIFT + Z + Z para guardar.</p>
                            <p>En la consola aparecer un mensaje:
                                <ul>
                                    <li> > Auto-merging css/estilos.css</li>
                                    <li> > Auto-merging blogpost.html</li>
                                </ul>
                            lo que significa que los archivos se estan auto fusionando.</p>
                            <p>Si ejecuto <span class="consola">git log</span>, podre leer los commit tanto de la rama MASTER como los de la rama CABECERA.</p>
                            <p>En el caso de estar trabajando en un proyecto con mas personas y no saber los nombres de sus ramas, puedo ejecutar el comando <span class="consola">git branch</span> y aparecerán todas las ramas disponibles. Aparecerá un signo de asterisco * para indicarme en que rama estoy.</p>
                            <img class="imagen-extra" src="img/16.2.jpg">
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado17">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso17" aria-expanded="false" aria-controls="panelColapso17">
                            Resolución de conflictos al hacer un merge
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso17" aria-labelledby="panelEncabezado17" data-bs-parent="#panelAcordion3">
                        <div class="accordion-body">
                            <p>Git no borra las ramas al hacer un merge. Si ejecuto checkout y entro a CABECERA, puedo ver el código de los archivos tal cual los tenia.</p>
                            <p>Ahora realizaremos un ejemplo al revés, traer los cambios de MASTER a CABECERA. Por ejemplo <span class="ejemplos">git merge master</span>.</p>
                            <p>Se fusionan todos los cambios, hasta el ultimo commit en donde se cambio la fuente. Ahora, por el momento tengo en ambas ramas la misma configuración y el mismo código.</p>
                            <p>En la rama CABERCERA voy a cambiar el texto del título de blogspot.html y el color en estilos.css a rojo.</p>
                            <p>Guardo los cambios. Por ejemplo <span class="ejemplos">git commit -am "Modifique la cabecera y el color del texto"</span></p>
                            <p>De vuelta en la rama MASTER, voy a cambiar el texto del título de blogspot.html por uno nuevo y el color en estilos.css a azul. Además agregare un párrafo más al final de blogspot.</p>
                            <p>Agrego los cambios a git. Por ejemplo <span class="ejemplos">git commit -am "Agregue suscripcion, cambie la cabecera maestra y puse todo azul"</span></p>
                            <p>Desde la rama MASTER voy a tratar de fusionarlos con la rama CABECERA. El nuevo párrafo no debería generar ningún problema, pero tanto el título del blog como el color darán errores.</p>
                            <p>Si ejecuto el merge. En la consola aparecera el siguiente error:
                                <ul>
                                    <li> > Auto-merging css/estilos.css</li>
                                    <li> > CONFLICT (content): Merge conflict in css/estilos.css</li>
                                    <li> > Auto-merging blogpost.html</li>
                                    <li> > CONFLICT (content): Merge conflict in blogpost.html</li>
                                </ul>
                            Hay un conflicto en estilos.css y en blogpost.html
                            </p>
                            <p>Dentro de visual studio también aparecerá el código con error. Los signos de menor que <<< indican donde comienza el conflicto y los signos de mayor que >>> hasta donde llega el conflicto.</p>
                            <p class="linea-separacion"></p>
                            <p><strong>Resolver conflictos</strong></p>
                            <p>En el caso del archivo estilos.css se puede editar de forma manual la propiedad color. Se puede elegir si mantener el color rojo, el color azul, o cambiarlo por un nuevo color. Y luego guardar los cambios desde visual studio.</p>
                            <p>Si veo el archivo de blogpost.html en Visual Studio CODE tengo la opcion de aceptar el cambio actual (accept current change), aceptar el cambio que viene (accept incoming change) o aceptar ambos cambios (accept both change)</p>
                            <p>Si ejecuto <span class="consola">git status</span> me dira que ambos archivos fueron modificados y que el merge aun no esta completo.</p>
                            <p>Como los cambios siguen en la etapa de staging, debo crear un nuevo commit para guardar la información. Por ejemplo <span class="ejemplos">git commit -am "Solucione el conflicto de las ramas al fusionar"</span></p>
                            <p class="notas">NOTA: SIEMPRE QUE HAGAS CAMBIOS A ARCHIVOS CON ERRORES DE MERGE RECUERDA APRETAR EL BOTÓN DE GUARDAR EN VISUAL STUDIO PARA QUE SEAN AGREGADOS EN EL COMMIT. RECUERDA MANTENER UNA COMUNICACIÓN ESTABLE CON TUS COMPAÑEROS DEL EQUIPO PARA ENTENDER DE FORMA MÁS PRECISA POR QUE SE PRODUCEN ERRORES AL MOMENTO DE UNIR RAMAS Y ASÍ PODER SOLUCIONARLAS EN COMUNIDAD.
                            </p>
                            <img class="imagen-extra" src="img/17.jpg">
                        </div>
                    </div>
                </div>
            </div>
            <!--cierre seccion capitulo tres-->

            <br>
            <!--inicio seccion capitulo cuatro-->
            <h3>Capítulo 4: trabajando con repositorios remotos en GitHub</h3>
            <div class="accordion accordion-flush" id="panelAcordion4">
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado19">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso19" aria-expanded="false" aria-controls="panelColapso19">
                            Uso de GitHub
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso19" aria-labelledby="panelEncabezado19" data-bs-parent="#panelAcordion4">
                        <div class="accordion-body">
                            <p>GitHub es un sitio web que está montado en un súper servidor de git en el que cualquier persona puede clonar su repositorio, o crear un repositorio y compartirlo con otras personas.</p>
                            <p>Se puede utilizar con una ventana grafica sin necesidad de estar trabajando en la consola todo el tiempo.</p>
                            <p>Lo primero que haremos es crear una cuento en github.com</p>
                            <p>Cuando tenga mi usuario creado:</p>
                            <ul>
                                <li>en el menú superior presionar el botón <button class="btn btn-secondary">+</button> donde tendremos varias opciones.</li>
                                <li>Para esta clase, seleccionamos <button class="btn btn-secondary">New Repository</button>.</li>
                                <li>Colocamos el nombre del repositorio: hyperblog</li>
                                <li>Colocamos una descripción: Blog del curso Profesional de Git y GitHub de Platzi.</li>
                                <li>Selecciono si el repositorio será público (lo puede ver todo el mundo) o privado (solo lo puedo ver yo). Para este ejercicio será Publico.</li>
                                <li>Una muy buena práctica es seleccionar la opción "Add a README file " para que se cree un archivo de leeme.</li>
                                <li>Las demás opciones las dejamos tal cual.</li>
                                <li>Finalmente presionamos el botón <button class="btn btn-secondary">Create repository</button>.</li>
                            </ul>
                            <p>Ya con el repositorio creado, si pincho sobre el archivo README.md se cambiara la página a una nueva en donde puedo ver las siguientes opciones:</p>
                            <ul>
                                <li><button class="btn btn-secondary">history</button> -> puedo ver la historia del repositorio, es igual a escribir el comando git log.</li>
                                <li><button class="btn btn-secondary">raw</button> -> un botón para ver el texto plano del archivo reedme.</li>
                                <li><button class="btn btn-secondary">blame</button> -> puedo ver los participantes de repositorio así como los commit que han publicado.</li>
                            </ul>
                            <p>Para subir los archivos de mi blog, en la página de GitHub presiono el botón <button class="btn btn-success">CODE</button></p>
                            <p>Luego selecciono la opción que dice HTTPS y copio la URL que me aparece.</p>
                            
                            <p class="linea-separacion"></p>
                            <p>Ahora de vuelta a la línea de comando, me aseguro que estoy en la rama master con pwd.</p>
                            <p>Le diré a git que voy a agregar un origen remoto de archivos. Eso se hace con el comando <span class="consola">git remote add origin</span>. Y para conectarlo con mi cuenta en GitHub quedaria asi: <span class="ejemplos">git remote add origin https://github.com/felipemunozca/hyperblog.git</span></p>
                            <p>Pareciera que no pasó nada, pero si escribo el comando <span class="consola">git remote</span>, aparece que ya existe un origen para la conexión.</p>
                            <p>Si ejecuto el comando <span class="consola">git remote -v</span> me mostrara un enlace hacia mi repositorio de GitHub con las opciones de fetch y push.</p>
                            <p>Ahora que se logró la conexión entre el git local en mi máquina y mi cuenta de GitHub, subiré los archivos de la rama master.</p>
                            <p><strong>NOTA IMPORTANTE:</strong> como ya no se utiliza la palabra master sino main, para ejecutar el código se deben concatenar ambos nombres de la siguiente manera: <span class="ejemplos">git push origin master:main</span></p>
                            <p>Si ejecuto el comando <span class="consola">git push</span>, se abrira una ventana en donde debo escribir mi correo y contraseña de mi cuenta de GitHub.</p>
                            <p>Si los pasos anteriores fueron correctos aparecerá un error que es normal.
                                <ul>
                                    <li> > ! [rejected]  master -> main (fetch first)</li>
                                </ul>
                                Este error significa que el servidor remoto tiene cambios que no he guardado en mi repositorio local. Esto significa que me falta el archivo README.md en mi máquina.
                            </p>
                            <p>Para solucionar este problema, lo primero es traer los archivos de mi repositorio remoto a mi repositorio local. Utilizo el comando <span class="consola">git pull</span> e indico la rama a la que estoy apuntando <span class="ejemplos">git pull origin main</span> (RECORDAR CAMBIAR MASTER POR MAIN)</p>
                            <p>Me podría aparecer un WARNING indicando que el repositorio remoto aún no tiene ningún commit.</p>
                            <p>En la consola puedo ver que mi cuenta de GitHub se fusionó con mi repositorio local
                                <ul>
                                    <li> > From https://github.com/felipemunozca/hyperblog</li>
                                    <li> > * branch            main       -> FETCH_HEAD</li>
                                    <li> > * [new branch]      main       -> origin/main</li>
                                </ul>
                            </p>
                            <p>Y además me mostrara un error diciendo que se reúsa a fusionar historias no relacionadas
                                <ul>
                                    <li> > fatal: refusing to merge unrelated histories</li>
                                </ul>
                            </p>
                            <p>Para solucionar el error de las historias, se ejecuta el siguiente comando: <span class="ejemplos">git pull origin main --allow-unrelated-histories</span>. Me aparecerá la consola VIM para escribir un comentario de la fusión de información.</p>
                            <p>Si voy a revisar mi repositorio en la página de GitHub aún no se ha subido ningún archivo. Tengo que volver a ejecutar el comando git push apuntando a main: <span class="ejemplos">git push origin master:main</span></p>
                            <p>Ahora los archivos son visibles desde la página de GitHub. Hasta puedo editarlos directamente desde ahí. Si voy al archivo blogpost.html y hago click, veré el código fuente, si presiono el botón <button class="btn btn-secondary">EDIT</button> y por ejemplo, cambio el titulo por "Bienvenido a hyperblog".</p>
                            <p>Después puedo hacer un PREVIEW a los cambios y agregar un commit "Cambie el titulo del blogpost" y en opcional "Porque puedo".</p>
                            <p>Me preguntara si quiero subir este commit a la rama main o si deseo crear una nueva rama con un nuevo nombre.</p>
                            <p>Para terminar, presionar el botón <button class="btn btn-secondary">Commit changes</button></p>
                            <p>Ahora en mi repositorio local no puedo ver los cambios que hice desde la página de GitHub a menos que vuelva a ejecutar el comando para descargar la actualización del codigo: <span class="ejemplos">git pull origin main</span></p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado20">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso20" aria-expanded="false" aria-controls="panelColapso20">
                            Cómo funcionan las llaves públicas y privadas
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso20" aria-labelledby="panelEncabezado20" data-bs-parent="#panelAcordion4">
                        <div class="accordion-body">
                            <p>Las aplicaciones de mensajería instantánea (Whatsapp, Telegram, Messenger) funcionan enviando mensajes entre personas y para evitar que esos mensajes sean leídos por terceros o por los llamados hackers, los mensajes son cifrados.</p>
                            <p>Para proteger el mensaje, se vinculan matemáticamente llaves públicas y llaves privadas.</p>
                            <p>¿Y cómo funcionan?</p>
                            <ul>
                                <li>Lo que yo cifro con mi llave publica, solo puede abrirlo mi llave privada.</li>
                                <li>Yo puedo enviar mi llave publica a cualquier persona, incluso publicarla en un blog.</li>
                                <li>Y con eso cualquier mensaje que me envíen solo podrá ser leído con mi llave privada.</li>
                                <li>Private Key: Para enviar información. Nunca se debe compartir</li>
                                <li>Public Key: Para recibir información. Esta se puede compartir</li>
                            </ul>
                            <img class="imagen-extra" src="img/20.jpg">
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado21">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso21" aria-expanded="false" aria-controls="panelColapso21">
                            Configura tus llaves SSH en local
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso21" aria-labelledby="panelEncabezado21" data-bs-parent="#panelAcordion4">
                        <div class="accordion-body">
                            <p>Cuando me conecte a GitHub mediante HTTPS mi usuario y contraseña se guardaron en mi entorno local. Si me roban mi computador, con algún programa para crackear contraseñas pueden dar con mis credenciales de GitHub. Lo que es un riesgo para la empresa en la que trabajo, ya que pueden acceder a los repositorios de la empresa.</p>
                            <p>Esta es la forma en la que puedes crear un hueco de seguridad en un servidor, por ejemplo, el de un banco, en donde podrías sacar dinero sin que nadie se entere.</p>
                            <p>Es por ese motivo que debe crear un entorno de seguridad mas fuerte. Se recomienda trabajar con comunicación mediante llaves públicas y privadas.</p>
                            <p>En mi entorno local (mi propio computador) voy a crear una llave publica y privada. Una vez que estén hechas, las enviare a GitHub y le indicare que "para este repositorio quiero que utilices esta llave publica de mi llave privada". Y eso lo conecto por un protocolo nuevo llamado SSH o Security SHell</p>
                            <p>Las llaves SSH no son por repositorio o por proyectos, SON POR PERSONAS.</p>
                            <p>Para hace un poco de memoria, si quiero cambiar la información del nombre de usuario y email con el que se conectara mi máquina, debo posicionar la consola en la carpeta raíz de git: <span class="ejemplos">Sxxxx@LAPTOP-630B MINGW64 ~</span></p>
                            <p>Luego puedo escribir el comando <span class="consola">git config -l</span> para ver la información de nombre de usuario y email.</p>
                            <p>Si se diera el caso de comenzar a trabajar en una empresa de desarrollo y me dan un correo corporativo, debo cambiar mi correo personal por el de mi empresa. Eso lo haria de la siguiente forma: <span class="ejemplos">git config --global user.mail "minombre@miempresa.cl"</span>. Ahora podremos crear la llave SSH, recuerda que también lo puedes hacer para tu cuenta personal y no es necesario que sea solo para una cuenta de empresa.
                            </p>
                            <p class="linea-separacion"></p>
                            <p><strong>Crear llaves</strong></p>
                            <p>Una vez ubicado en el home del directorio de git <span class="ejemplos">Sxxxx@LAPTOP-630B MINGW64 ~</span></p>
                            <p>se escribe el siguiente comando: <span class="ejemplos">ssh-keygen -t rsa -b 4096 -C "anxxxxxxxxxxxx@xxxxxxxx.com"</span></p>
                            <ul>
                                <li>-t -> especifica cual es el algoritmo que voy a utilizar</li>
                                <li>rsa -> algoritmo más popular debido a su complejidad</li>
                                <li>-b -> que tan compleja es la llave</li>
                                <li>4096 -> complejidad de la llave desde una perspectiva matemática</li>
                                <li>-C -> c mayúscula -> a que correo electrónico va a estar conectada esta llave. Idealmente se debe escribir el mismo correo que se definió en la configuración global.</li>
                            </ul>
                            <p>Me preguntara donde guardar la llave. Por recomendación es mejor no cambiar nada y solo presionar ENTER.</p>
                            <p>Luego me pedirá un passphrase (significa password con espacios). Por lo general se recomienda ingresar una contraseña para mas seguridad. (Para este curso no será necesario así que solo se debe presionar la tecla ENTER)</p>
                            <p>Si busco en la consola puedo ver el siguiente texto en donde se confirma la creación de la llave:</p>
                            <ul>
                                <li> > The key fingerprint is: Sxxxxx:8xxxxxxxxxxxxxxxxxxxxxxx anxxxxxxxxxxxx@xxxxxxxx.com</li>
                            </ul>
                            <p>Dentro de mi computador, si voy a la siguiente ruta C:\Users\Spr\.ssh podre ver mi llave privada y pública.</p>
                            <p>Para poder comenzar a hacer conexiones seguras, lo primero es revisar si mi sistema Windows tiene un programa corriendo que revisa las conexiones ssh. Para esto, dentro de la misma consola de git bash ejecutar el comando: <span class="ejemplos">eval $(ssh-agent -s)</span></p>
                            <p>Si ejecuto el comando me aparecerá la siguiente respuesta: <span class="ejemplos">Agent pid 1983</span> (El numero puede ser diferente en cada equipo).</p>
                            <p>Ahora debo agregar la llave al sistema operativo. Para agregar la llave, debo ejecutar el siguiente comando: <span class="ejemplos">ssh-add ~/.ssh/id_rsa</span></p>
                            <p>Si se ejecuta correctamente veré el siguiente mensaje en la consola: <span class="ejemplos">Identity added: /c/Users/Sxxxx/.ssh/id_rsa (anxxxxxxxxxxxx@xxxxxxxx.com)</span></p>
                            <p class="notas">NOTA: si utilizo el signo ~ dentro de la consola podre ir directo a mi carpeta home. Además, si escribo el nombre de la carpeta puedo ir directo al repositorio por ejemplo: <span class="ejemplos">~/proyecto1</span> </p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado22">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso22" aria-expanded="false" aria-controls="panelColapso22">
                            Conexión a GitHub con SSH
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso22" aria-labelledby="panelEncabezado22" data-bs-parent="#panelAcordion4">
                        <div class="accordion-body">
                            <p>Es importante aclarar. Si tengo 3 computadores, debo tener una llave pública y privada distinta por cada equipo.</p>
                            <p>Utilizando Visual Studio, abro la llave id_rsa.pub</p>
                            <p>En el navegador, entro a mi cuenta de GitHub, en el menú superior, en donde sale la fotografía de mi cuenta, presiono para que se despliegue el menú y luego voy al botón <button class="btn btn-secondary">SETTINGS</button>.</p>
                            <p>Me dirijo hacia donde dice <button class="btn btn-secondary">SSH and GPG keys</button>. Luego presiono el botón <button class="btn btn-secondary">New SSH key</button>.</p>
                            <p>Escribo un título. Recomendación; escribir un nombre que se asocie a mi computador.</p>
                            <p>En key pego el código de mi archivo id_rsa.pub . Finalmente presiono el botón <button class="btn btn-secondary">Add SSH Key</button>. Me pedirá mi contraseña de GitHub para continuar. Si todo resulto bien, puedo ver los datos de la llave en la pantalla del navegador.</p>
                            <p>Ahora volveré a pinchar el menú superior e iré a la sección <button class="btn btn-secondary">Your repository</button>. Luego iré a la página del repositorio del blogpost, presiono el botón <button class="btn btn-success">CODE</button> y en vez de utilizar la conexión mediante HTTPS presiono <button class="btn btn-secondary">SSH</button> para generar la URL.</p>
                            <p>En la consola de git bash vuelvo a entrar a la carpeta proyecto1. Ejecuto el comando <span class="consola">git remote -v</span> para ver las URL de mi repositorio, fetch y push.</p>
                            <p class="notas">NOTA: origin ES UN ESTANDAR DE LA INDUSTRIA, YO LE PODRIA COLOCAR EL NOMBRE QUE QUISIERA.</p>
                            <p class="linea-separacion"></p>
                            <p><strong>Conexión con SSH</strong></p>
                            <p>Lo primero que debo hacer es cambiar la url del servidor remoto, en gitbash escribo el siguiente comando: <span class="ejemplos">git remote set-url origin git@github.com:felipemunozca/hyperblog.git</span></p>
                            <p>Vuelvo a ejecutar el comando <span class="consola">git remote -v</span> y ahora aparece que la conexión se realiza de esta manera:
                                <ul>
                                    <li><span class="ejemplos">origin  git@github.com:felipemunozca/hyperblog.git (fetch)</li>
                                    <li><span class="ejemplos">origin  git@github.com:felipemunozca/hyperblog.git (push)</li>
                                </ul>
                            </p>
                            <p>Lo primero que tengo que hacer es traer la última versión del repositorio con <span class="consola">git pull</span> de GitHub (esto es una buena práctica y evita errores)</p>
                            <p>Me aparecerá un mensaje preguntando si la autenticidad de mi llave es real y debo responder yes o no. Como no pudo encontrar cambios, vuelvo a realizar el comando esta vez apuntando al directorio main: <span class="ejemplos">git pull origin main</span></p>
                            <p>Realizo algunos cambios al archivo blogpost.html y lo reviso con <span class="consola">git status</span> para ver si lo reconoce como pendiente. Guardo los cambios con un commit: <span class="ejemplos">git commit -am "Se crea una nueva versión del hyperblog"</span></p>
                            <p>Ahora si subo los archivos a GitHub con el comando: <span class="ejemplos">git push origin master:main</span>. En el navegador puedo visualizar si los cambios en el archivo blogpost.html se subieron.</p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado23">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso23" aria-expanded="false" aria-controls="panelColapso23">
                            Tags y versiones en Git y GitHub
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso23" aria-labelledby="panelEncabezado23" data-bs-parent="#panelAcordion4">
                        <div class="accordion-body">
                            <p>Si queremos saber el historial del proyecto, podemos utilizar el comando <span class="consola">git log</span> para ver todos los commit de mi proyecto hasta ahora.</p>
                            <p>Además, Podemos utilizar variantes para ver los log.</p>
                            <p><span class="consola">git log --all</span> -> muestra todo lo que hemos hecho.</p>
                            <p><span class="consola">git log --graph</span> -> muestra líneas de colores en la parte izquierda donde podre ver cuando dos ramas se han unido mediante merge.</p>
                            <p><span class="consola">git log --graph --decorate --oneline</span> -> comando para ver toda la historia de una forma mas ordenada y fácil de leer. Hace que los hash o id de cada commit sean más fáciles de leer ya que se acortan mucho, por ejemplo: <span class="ejemplos">31af3fc cambio de maestría</span> o <span class="ejemplos">1a5ac3b cambio de historia por vida</span></p>
                            <p class="linea-separacion"></p>
                            <p><strong>Tags</strong></p>
                            <p>Los tags permiten asignar versiones a los commits con cambios más importantes o significativos de nuestro proyecto.</p>
                            <p>Lo primero es copiar el id desde <span class="consola">git log --graph --decorate --oneline</span> y luego escribir el siguiente comando, <span class="consola">git tag -a</span> con el nombre de la version, y recordando que es un commit asi que tambien debe llevar un mensaje. Y al final, debo agregar el id que copie. Por ejemplo: <span class="ejemplos">git tag -a v0.1 -m "Resultado de las primeras clases del curso" 45ee9d4</span></p>
                            <p class="notas">Una buena práctica es colocar la versión del proyecto incluyendo la v y un número que pueda ser correlativo ej: v0.1</p>
                            <p>Aparentemente no paso nada, pero si ejecuto el comando <span class="consola">git tag</span> veré cuantos tags se han registrado en el proyecto.</p>
                            <p>Para saber en qué punto fue creado la versión v0.1 puedo ejecutar el comando: <span class="consola">git show-ref --tags</span>. En la respuesta aparecerá el id del commit el cual use como base para crear la versión. Por ejemplo: <span class="ejemplos">d6dd22f35abb8f24d7740ca9fdeb23e9 refs/tags/v0.1</span></p>
                            <p>Los tags son útiles en GitHub para marcar un punto específico en la historia de nuestro proyecto (para los releases). De esta forma podemos hacer un seguimiento del progreso de nuestro proyecto e identificar los cambios que se han hecho en cada versión de manera más fácil.</p>
                            <p>Ahora enviamos los tags a GitHub <span class="consola">git push origin --tags</span></p>
                            <p>En el navegador, en el repositorio del proyecto, si pincho el boton <button class="btn btn-secondary">main</button>, luego voy a la pestaña "Tags" aparecerá v0.1</p>
                            <p>¿Qué pasa si creamos un tags que no nos gusta?</p>
                            <ul>
                                <li>Elegimos cualquier id y ejecutamos el comando: <span class="ejemplos">git tag -a dormido -m "ajsjdjahdj jashdjashdjas ashdjash" 37ae1d1</span></li>
                                <li>Luego me traigo los archivos que hay en el servidor remoto con pull y subo los cambios con push --tags</li>
                                <li>Vuelvo a ver el repositorio en el navegador y dentro de main -> tags -> aparece "dormido".</li>
                                <li>Si lo quiero eliminar, lo puedo hacer desde la interfaz de GitHub, pero lo mejor es aprender a hacerlo desde la consola.</li>
                                <li>Escribo el comando <span class="consola"></span>git tag para saber los tags que existen.Cuando ya se el que quiero eliminar escribo el siguiente comando: <span class="ejemplos">git tag -d dormido</span></li>
                                <li>Aparece el siguiente mensaje: Deleted tag 'dormido' (was c3bf090)</li>
                                <li>Para guardar los cambios primero traigo cualquier cambio del servidor con <span class="consola">git pull origin main</span> y luego actualizo los tags con <span class="consola">git push origin --tags</span></li>
                                <li>Si voy nuevamente al navegador y reviso los tags del proyecto seguirá apareciendo "dormido", y eso es porque no se borra de forma automática de GitHub ya que puede ser utilizado como un release, es decir, que es asumir que algo está listo, es una versión estable utilizable.</li>
                                <li>Entonces para eliminarlo de forma completa, vuelvo a la consola de gitbash y escribo el siguiente comando: <span class="ejemplos">git push origin :refs/tags/dormido</span></li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado24">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso24" aria-expanded="false" aria-controls="panelColapso24">
                            Manejo de ramas en GitHub
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso24" aria-labelledby="panelEncabezado24" data-bs-parent="#panelAcordion4">
                        <div class="accordion-body">
                            <p>comenzaremos con un repaso de los comandos importantes de ramas:</p>
                            <ul>
                                <li><span class="">checkout</span> -> cambiar de rama. Por ejemplo <span class="ejemplos">git checkout cabecera</span></li>
                                <li><span class="">branch</span> -> me muestra todas las ramas que existen. Por ejemplo  <span class="consola">git branch</span></li>
                                <li><span class="">show-branch</span> -> nos muestra cuales son las ramas que existen y cuales han sido su historia. Por ejemplo <span class="consola">git show-branch</span></li>
                                <li><span class="">show-branch --all</span> -> nos muestra cuales son las ramas que existen y su historia con mucho mas detalles. Por ejemplo <span class="consola">git show-branch --all</span></li>
                                <li><span class="">gitk</span>-> comando con el que se abrirá un software con el que podemos ver de forma gráfica las ramas, commit, tags (se instala por defecto). <p class="notas">NOTA: para poder seguir escribiendo en la consola, debo cerrar el programa que se abrió antes.</p></li>
                                <li><span class="">pull</span> -> traemos los cambios de GitHub. Por ejemplo  <span class="ejemplos">git pull origin cabecera</span></li>
                                <li><span class="">checkout</span> -> para movernos entre las ramas. Por ejemplo <span class="ejemplos">git checkout cabecera</span></li>
                                <li><span class="">push</span> -> subimos los cambios de la rama en la que estoy a GitHub. Por ejemplo <span class="ejemplos">git push origin cabecera</span></li>
                            </ul>
                            <p class="linea-separacion"></p>
                            <p><strong>Branch (Ramas)</strong></p>
                            <p>Desde la rama principal, creare dos nuevas ramas; header y footer.</p>
                            <p>Para comenzar, creare la rama header con el comando: <span class="ejemplos">git branch header</span></p>
                            <p>Y a continuación creo la rama del footer con el comando: <span class="ejemplos">git branch footer</span></p>
                            <p>Para revisar si las ramas se crearon, ejecuto el comando <span class="consola">git branch</span> y aparecerán todas las ramas disponibles. (aparecerá el signo * en la rama que me encuentro en este momento)
                                <ul>
                                    <li> > * cabecera</li>
                                    <li> > footer</li>
                                    <li> > header</li>
                                    <li> > master</li>
                                </ul>
                           </p>
                            <p>Ahora subiré las nuevas ramas creadas a GitHub, primero con la rama header: <span class="ejemplos">git push origin header</span> y luego la rama footer: <span class="ejemplos">git push origin footer</span></p>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado25">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso25" aria-expanded="false" aria-controls="panelColapso25">
                            Configurar múltiples colaboradores en un repositorio de GitHub
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso25" aria-labelledby="panelEncabezado25" data-bs-parent="#panelAcordion4">
                        <div class="accordion-body">
                            <p>Yo puedo buscar un proyecto en GitHub que me interese y "clonarlo" para hacer mis propios cambios, pero eso no significa que yo pueda "Enviar" nueva información a ese repositorio.</p>
                            <p>En GitHub, busco el proyecto de hyperblog de Freddier, pincho el boton CODE para clonarlo, copiando la URL de HTTPS</p>
                            <p>En la consola voy a la carpeta donde creare el proyecto. Por ejemplo: <span class="ejemplos">/Users/SprXXXXX/proyecto2</span>, luego escribo el comando clone junto a la url. Por ejemplo <span class="ejemplos">git clone https://github.com/felipemunozca/hyperblog.git</span></p>
                            <p>Se descargar los archivos a mi git local, pero en ningún momento me pedirá ni usuario ni contraseña. Esto es porque es un repositorio público.</p>
                            <p>Al ejecutar el comando <span class="consola">git log</span>, podre leer toda la historia del proyecto. Y si ejecuto el comando <span class="consola">git branch</span> me aparecerá que solo se descargó la rama MASTER.</p>
                            <p>Luego de leer el historial del proyecto, ejecuto el archivo blogpost.html y trato de realizar cambios para subirlos a GitHub ejecutando el comando <span class="ejemplos">git push origin master:main</span></p>
                            <p>Me pedirá el usuario y contraseña, los escribo. Luego aparece un error indiciando "Permision denied" o Permisos denegados. Si la persona no está agregada al repositorio, no podrá subir cambios.</p>
                            <p class="linea-separacion"></p>
                            <p><strong>Permisos de colaboradores en GitHub </strong></p>
                            <p>Para agregar a un colaborador al proyecto, debo ir al repositorio hyperblog.</p>
                            <p>En el menu nav debajo del nombre, ir hasta la sección donde dice <button class="btn btn-secondary">Settings</button>. Ir hasta el menú lateral izquierdo y seleccionar <button class="btn btn-secondary">Manage Access</button>.</p>
                            <p>En la nueva página, presionar el botón <button class="btn btn-success">Add People</button>. En el área de texto escribo el correo de la persona Por ejemplo: "anita@gmail.com". Si el email no aparece como disponible, es porque no está en modo público.</p>
                            <p class="notas">Si no quiero que mi email sea público para evitar que me mandan correos no deseados, puedo decirle a la persona que me diga su nombre de usuario de su cuenta de GitHub y agregarlo con ese nombre.</p>
                            <p>Escribo el nombre "AnitaPlatzi" y luego presiono el botón <button class="btn btn-secondary">Add to this repository</button>. Ahora AnitaPlatzi debe aceptar la invitación a participar. Si lo hace podrá subir cambios nuevos al proyecto utilizando push.</p>
                            <p class="notas">Nota: cuando me invitan a trabajar en un proyecto, lo recomendado es hacerlo en una rama nueva, crear todos los cambios que se me pidan o que considere necesarios, luego los subo y le doy aviso a la persona a cargo para que los revise y vea si realmente sirven. Si es así en ese momento se crea un merge con la rama main, antes NO SE TOCA la rama main.</p>
                        </div>
                    </div>
                </div>
            </div>
            <!--cierre seccion capitulo cuatro-->

            <br>
            <!--inicio seccion capitulo cinco-->
            <h3>Capítulo 5: Flujos de trabajo profesionales</h3>
            <div class="accordion accordion-flush" id="panelAcordion5">
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado26">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso26" aria-expanded="false" aria-controls="panelColapso26">
                            Haciendo merge de las ramas de desarrollo a la rama master(main)
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso26" aria-labelledby="panelEncabezado26" data-bs-parent="#panelAcordion5">
                        <div class="accordion-body">
                            <p>Para continuar con el ejercicio. Yo me encargare del header y Anita del footer.</p>
                            <p class="notas">UN DATO IMPORTANTE: las imágenes son archivos binarios, y las buenas practicas dicen que los archivos binarios NO SE DEBEN AGREGAR A REPOSITORIOS. Deben ser ignorados.</p>
                            <p>En este ejercicio SI lo agregaremos para saber qué es lo que pasa con el repositorio.</p>
                            <p>Me dirijo a la rama header y agrego la imagen con el comando <span class="ejemplos">git add imagenes/dragon.png</span></p>
                            <p>Ahora ejecuto el comando <span class="consola">git status</span> y veo que el archivo fue reconocido y agregado. Continuo con un commit para salvar los cambios. Por ejemplo <span class="ejemplos">git commit -am "logo del header"</span></p>
                            <p>Ahora toca subir estos cambios al repositorio en GitHub. Lo primero es traer cualquier cambio que pueda tener la rama header <span class="ejemplos">git pull origin header</span> Ahora subo los cambios del header junto con la imagen <span class="ejemplos">ej: git push origin header</span></p>
                            <p>Ahora si voy al navegador, a la página del repositorio hyperblog en el branches -> header debería estar la nueva carpeta y el nuevo archivo.</p>
                            <p>¿Cuál es el problema de trabajar con imágenes?</p>
                            <ul>
                                <li>Cada vez que yo haga cambios, voy a traer más binarios a mi repositorio, lo que lo hará mucho más pesado.</li>
                                <li>Por ejemplo, si se abre la imagen dragon.png con paint y se le agrega una carita feliz, cuando se guarde ese cambio, con git status podremos ver que se registró un cambio en el peso del archivo. Ahora tocaría crear un commit y volver a subirlo a GitHub.</li>
                                <li>Algunas veces GitHub tarda en mostrar los cambios que se hicieron en una imagen ya que se guardan en una cache intermedia que puede demorarse en procesar los cambios.</li>
                            </ul>
                            <p>Agrego nuevos cambios a los archivos de blogpost.html y estilos.css y los guardo con un nuevo commit <span class="ejemplos">git commit -am "color de fondo, logo nuevo y mejor color de header"</span></p>
                            <p>Ahora los cambios quedan guardados en mi repositorio local, pero aun no los subo ya que quiero saber cómo va Anita con la rama footer. Anita agrega un footer en el html además de crear sus estilos css y los sube a su propia rama.</p>
                            <p class="linea-separacion"></p>
                            <p><strong>Merge de diferentes ramas </strong></p>
                            <p>Anita me avisa que termino los cambios que le pidieron así que debo descárgalos desde su rama <span class="ejemplos">git pull origin footer</span></p>
                            <p>Reviso los cambios Y si están correctos, el encargado del proyecto (en este ejemplo yo) determina que tanto el header como el footer están correctos, asi que sedebe hacer un merge de ambos a la rama MAIN</p>
                            <p>El listado de comandos para realizar la fusión es el siguiente:</p>
                            <ul>
                                <li><span class="ejemplos">git checkout master</span></li>
                                <li><span class="ejemplos">git merge header</span> -> escribir el commit del porque se hace la fusión con el header</li>
                                <li><span class="ejemplos">git merge footer</span> -> escribir el commit del porque se hace la fusión con el footer</li>
                                <li><span class="ejemplos">git pull origin main </span></li>
                                <li><span class="ejemplos">git push origin master:main</span></li>
                            </ul>
                            <p class="linea-separacion"></p>
                            <p><strong>Desafío Freddy</strong></p>
                            <p>Descargar el proyecto hyperblog desde el perfil freddier, en el archivo blogpost.html agregar mi nombre debajo del ultimo estudiante, guardar los cambios y subirlos para esperar a que hagan el merge.</p>
                            <p>Comandos utilizados:</p>
                            <ul>
                                <li><span class="ejemplos">git checkout master</span></li>
                                <li><span class="ejemplos">git pull origin header</span></li>
                                <li><span class="ejemplos">git status</span></li>
                                <li><span class="ejemplos">git log </span></li>
                                <li><span class="ejemplos">git merge header )</span> (no me apareció la pantalla para escribir el commit</li>
                                <li><span class="ejemplos">git pull origin main </span></li>
                                <li><span class="ejemplos">git push origin master:main</span></li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado27">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso27" aria-expanded="false" aria-controls="panelColapso27">
                            Flujo de trabajo profesional con Pull requests
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso27" aria-labelledby="panelEncabezado27" data-bs-parent="#panelAcordion5">
                        <div class="accordion-body">
                            <p>En la clase anterior, realizamos un merge directo a la rama MAIN.</p>
                            <p>En un entorno profesional normalmente se bloquea la rama MAIN. La idea es que nadie pueda llegar y hacer un merge sin antes revisar el código.</p>
                            <p>La rama MASTER o MAIN es la que eventualmente se subirá al servidor real, llamado <strong>SERVIDOR DE PRODUCCIÓN</strong> que es el que se abre desde un navegador, por ejemplo: www.versionfinal.com o también es donde se sube nuestra compilación final de una aplicación móvil antes de enviarla appstore o play store.</p>
                            <p>Cuando tenemos que hacer pruebas, deben ser en un entorno que se parezca al de producción, que sea lo más similar al entorno real posible, sin que afecte a los usuarios. Si mi aplicación está corriendo en un sitio, por ejemplo www.hyperblog.com puedo crear un subdominio como test.hyperblog.com y los archivos son subidos y modificados en un servidor llamado <strong>SERVIDOR DE DESARROLLO</strong> o <strong>SERVIDOR STAGING</strong> .</p>
                            <p>En un entorno profesional, la forma de trabajar con estos servidores es crear los cambios en una rama asignada, por ejemplo, footer, header, etc. Este código debe ser revisado y es enviado a un entorno conocido como PULL REQUEST. Lo que permite que otros miembros del equipo lo vean y analicen los cambios. Si están de acuerdo, se puede hacer un merge hacia el SERVIDOR STAGING.</p>
                            <p><strong>PULL REQUEST</strong> es una característica que solo GitHub tiene, no se podrá ejecutar en el repositorio git local de mi máquina.</p>
                            <p>La persona que en la vida real hace todo esto normalmente, es la líder del equipo o también un perfil de desarrollador más capacitado llamado DEV OPS (administrador del entorno de desarrollo)</p>
                            <img class="imagen-extra" src="img/27.jpg">
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header" id="panelEncabezado28">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelColapso28" aria-expanded="false" aria-controls="panelColapso28">
                            Utilizando Pull Requests en GitHub
                        </button>
                    </h2>
                    <div class="accordion-collapse collapse" id="panelColapso28" aria-labelledby="panelEncabezado28" data-bs-parent="#panelAcordion5">
                        <div class="accordion-body">
                            <p>imaginemos que encontramos errores ortográficos en los textos del blog. Para hacer una revisión de todos los textos que se ven en la página del blog, lo mejor es crear una nueva rama dedicada a buscar estos errores. Por ejemplo <span class="ejemplos">git branch fix-type</span></p>
                            <p>Una vez que este en la rama nueva, puedo ir al blogpost.html y corregir el texto. Revisamos los cambios con <span class="consola">git status</span>. Guardamos con los cambios con un commit, por ejemplo: <span class="ejemplos">git commit -am "Tildes y textos nuevos en el blog"</span></p>
                            <p>Ahora puedo subir los cambios al servidor <span class="ejemplos">git push origin fix-type</span></p>
                            <p>En la página de GitHub aparecerá un mensaje que nos dice que se detectó una diferencia entre el contenido subido a "fix-type" y la rama "main"</p>
                            <p class="linea-separacion"></p>
                            <p><strong>Pull Request en GitHub</strong></p>
                            <p>Si yo soy el dueño del repositorio, y estoy en la rama master o MAIN, puedo presionar el botón <button class="btn btn-secondary">Pull request</button> del menú superior.</p>
                            <p>En la nueva página abierta, puedo presionar el botón <button class="btn btn-secondary">New pull request</button>. Aquí voy a poder comparar mi rama principal "base: main" con otra que tenga disponible "compare: fix-type"</p>
                            <p>Si bajo un poco, podre ver una vista previa en donde aparecerá el código original. En rojo estará el código tenía antes de editarlo y en verde el nuevo código agregado o modificado. Si todo está bien y no es necesario más cambios, subo un poco y presiono el botón <button class="btn btn-secondary">Create pull request</button>.</p>
                            <p>En la pantalla del pull request podre escribir un mensaje explicando porque se está haciendo este merge.</p>
                            <p class="notas">NOTA: puedo ahorrarme todos estos pasos anteriores, en la página principal de mi repositorio hyperblog, aparecerá un mensaje indicando que en una nueva rama "fix-type" se detectaron cambios que no están en MAIN. Así que se puede presionar el botón "Compare & pull request" para llegar directo a escribir el commit.</p>
                            <p>Otra ventaja de GitHub es que puedo agregar personas para que revisen este “pull request”, esto se hace al ir al menú a mano derecha en la sección "Reviewers"</p>
                            <p>Para finalizar, presiono el boton <button class="btn btn-secondary">Create pull request</button>.</p>
                            <p class="linea-separacion"></p>
                            <p>Ahora pensando en la perspectiva de la persona que agregue como encargada de revisar el request, una vez que entre a GitHub, le aparecerá un indicador en la sección “pull request”. Al entrar podrá leer el nombre con el que fue guardado y luego los detalles que fueron descritos como mensaje. .</p>
                            <p>Puede ver los commit disponibles, pudiendo ser 1 o muchos, dependiendo de qué tantas cosas se corrigieron. En la sección "File changed" la persona vera los cambios en el código, lo que quedo igual en blanco, lo corregido en rojo y lo nuevo en verde.</p>
                            <p>Ahora la persona tiene 3 opciones, Si presiona el botón <button class="btn btn-secondary">review changes</button> podrá elegir entre:</p>
                            <ul>
                                <li>comentar</li>
                                <li>aprobar</li>
                                <li>pedir cambios</li>
                            </ul>
                            <p>Para este ejercicio, la persona rechazo nuestros cambios, así que dejara un mensaje con la respuesta, seleccionara "request changes" y presionara el boton <button class="btn btn-secondary">submit review</button>.</p>
                            <p class="linea-separacion"></p>
                            <p>Ahora en mi perfil, tendré una notificación que la persona que reviso mi pull request me está pidiendo cambios. Así que en mi entorno local, descargo la rama con push, realizo los cambios en el archivo y los vuelvo a subir con pull.</p>
                            <p>De vuelta en GitHub, ahora debería aparecer un botón que dice <button class="btn btn-secondary">View #1</button> con el cual puedo ver nuevamente los cambios en "File changes". Le dejo un mensaje a la persona para que vea que los cambios ya fueron subidos, para que apruebe el merge.</p>
                            <p class="linea-separacion"></p>
                            <p>La otra persona revisa los cambios y ahora todo está bien, entonces podrá dejar un mensaje, seleccionar "Approve" y pinchar el botón <button class="btn btn-secondary">Submit review</button>.</p>
                            <p>Que los cambios estén aprobados no significa que el merge se haya ejecutado. Se debe respetar a la persona que esta a cargo del proyecto, por lo general, el es el encargado de realizar los merge.</p>
                            <p>De vuelta en la "Conversation" del request, se puede ir al boton <button class="btn btn-secondary">Merge pull request</button>. Dejo el commit que viene por defecto o puedo escribir uno mas especifico y con mas detalles. Para terminar presiono el boton <button class="btn btn-secondary">Confirm merge</button>.</p>
                            <p>Si el merge se ejecuta de forma correcta aparecerá un mensaje indicando "successfully" que todo resulto bien.</p>
                            <p>Y además tendré un boton <button class="btn btn-secondary">Delete branch</button> con el que puedo eliminar la rama creada para reparar el error y así evitar llenarse de ramas. Esta decisión dependerá de cada equipo de trabajo. Para este ejercicio se eliminará la rama fix-type.</p>
                        </div>
                    </div>
                </div>
            </div>            
            <!--cierre seccion capitulo cinco-->

        </div>
    </div>
    <br>
    <!--bootstrap 5-->
    <script src="js/bootstrap.bundle.min.js"></script>
    <!--
    <script src="js/bootstrap.min.js"></script>
    -->
</body>
</html>